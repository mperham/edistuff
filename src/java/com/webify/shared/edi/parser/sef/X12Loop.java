package com.webify.shared.edi.parser.sef;


import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


/**
 * @author mperham
 * @version $Id: X12Loop.java 662 2004-11-19 17:02:12Z mperham $
 */
public class X12Loop extends X12Element {

    /**
     * Controls whether we should emit the bean subclasses.  These
     * classes are designed to modify bean behavior and hold helper
     * methods so we only want to generate them when first creating
     * the object model from SEF.
     */
    private static boolean generateSubclassFiles = Boolean.getBoolean("generate.subclasses");

    private X12LoopTrigger trigger;
    private List loops = null;
    private List segments = null;
    private List elements = null;
    private short curOrdinal = 1;
    private Map nameMap = new HashMap();
    private boolean hasHierarchy = false;

    private X12Loop parentLoop, childLoop;

    public boolean segmentExists(String name) {
        return nameMap.get(name) != null;
    }

    public Map getSegmentMap() {
        return nameMap;
    }

    public List getLoops() {
        if (loops == null) {
            return Collections.EMPTY_LIST;
        }
        return loops;
    }

    public List getSegmentReferences() {
        if (segments == null) {
            return Collections.EMPTY_LIST;
        }
        return segments;
    }

    protected List getElements() {
        if (elements == null) {
            return Collections.EMPTY_LIST;
        }
        return elements;
    }

    public void addLoop(X12Loop loop) {
        if (loops == null) {
            loops = new ArrayList();
        }
        loops.add(loop);
        addElement(loop);
    }

    public void addSegmentReference(X12SegmentReference seg) {
        if (segments == null) {
            segments = new ArrayList();
        }
        nameMap.put(seg.getName(), seg);
        segments.add(seg);
        addElement(seg);
        if (segments.size() == 1) {
            if (seg.isRequired()) {
                this.setOptional(false);
            }
            this.setUsageNote(seg.getUsageNote());
        }
        if (seg.getOrdinal() == 0) {
            seg.setOrdinal(curOrdinal++);
        }
        else {
            curOrdinal = seg.getOrdinal();
        }
    }

    private void addElement(X12Element elem) {
        if (elements == null) {
            elements = new ArrayList();
        }
        elements.add(elem);
    }

    public void toDebugString(StringBuffer sb, int lvl) {
        super.toDebugString(sb, lvl);

        String name = this.getClass().getName();

        sb.append(name.substring(name.lastIndexOf('.') + 1)).append(" \"").append(getName());
        sb.append("\" [").append(getMaxUsage()).append("]\n");

        for (Iterator iter = getSegmentReferences().iterator(); iter.hasNext();) {
            X12SegmentReference element = (X12SegmentReference) iter.next();

            element.toDebugString(sb, lvl + 1);
        }
        for (Iterator iter = getLoops().iterator(); iter.hasNext();) {
            X12Loop element = (X12Loop) iter.next();

            element.toDebugString(sb, lvl + 1);
        }
    }

    public String getJavaType() {
        return "Loop" + getName();
    }

    private boolean hasHierarchy() {
        return hasHierarchy;
    }

    public void emit(String xaType) throws IOException {
        precalculateHierarchy();

        FileWriter fw = new FileWriter("Base" + getJavaType() + ".java");
        PrintWriter out = new PrintWriter(fw);
        String type = null;

        try {
            out.println("package com.webify.shared.edi.model.hipaa" + xaType + ".beans;");
            out.println();
            out.println("import com.webify.shared.edi.model.*;");
            out.println("import com.webify.shared.edi.model.hipaa" + xaType + ".*;");
            out.println("import org.apache.commons.logging.Log;");
            out.println("import org.apache.commons.logging.LogFactory;");
            out.println("import java.io.IOException;");
            out.println("import java.util.*;");
            out.println();
            out.println("/*");
            out.println(" * AUTOGENERATED FILE - DO NOT EDIT!!!");
            out.println(" */");
            emitHeader(out, xaType);
            out.println();
            out.println(
                    "\tprivate static final Log log = LogFactory.getLog(" + getJavaType()
                    + ".class);");
            out.println();

            out.println("\tprivate int startLineNumber, endLineNumber;");
            out.println("\tpublic int getStartLineNumber() { return startLineNumber; }");
            out.println("\tpublic int getEndLineNumber() { return endLineNumber; }");
            out.println();
            out.println("\t/** Do NOT use this method - it is not public by choice... */");
            out.println("\tpublic void setEndLineNumber(int foo) { endLineNumber = foo; }");
            out.println("\t/** Do NOT use this method - it is not public by choice... */");
            out.println("\tpublic void setStartLineNumber(int foo) { startLineNumber = foo; }");
            out.println();

            if (getTrigger() != null) {
                X12LoopTrigger theTrigger = getTrigger();

                out.println("\tpublic static final String[] TRIGGER_VALUES = new String[] {");
                out.print("\t\t");
                String[] arr = theTrigger.getValues();

                for (int i = 0; i < arr.length; i++) {
                    out.print("\"" + arr[i] + "\"");
                    if (i + 1 < arr.length) {
                        out.print(", ");
                    }
                }
                out.println();
                out.println("\t};");
                out.println();
            }

            if (getChildLoop() != null) {
                X12Loop subloop = (X12Loop) getChildLoop();

                out.println("\tprivate List children;");
                out.println("\tpublic void setChildList(List kids) { children = kids; }");
                out.println("\tpublic List getChildList() { ");
                out.println("\t\tif (children == null) return Collections.EMPTY_LIST;");
                out.println("\t\treturn children;");
                out.println("\t}");
                out.println();
                out.println("\tpublic void addChild(" + subloop.getJavaType() + " kid) {");
                out.println("\t\tif (children == null) children = new ArrayList();");
                out.println("\t\tchildren.add(kid);");
                out.println("\t}");
                out.println("\tpublic " + subloop.getJavaType() + "[] getChildren() { ");
                out.println("\t\tList kids = getChildList();");
                out.println(
                        "\t\treturn (" + subloop.getJavaType() + "[]) kids.toArray(new "
                        + subloop.getJavaType() + "[kids.size()]);");
                out.println("\t}");
                out.println("\tpublic " + subloop.getJavaType() + " getChild(int idx) { ");
                out.println("\t\tif (children == null || idx >= children.size()) {");
                out.println("\t\t\tthrow new ArrayIndexOutOfBoundsException(Integer.toString(idx));");
                out.println("\t\t}");
                out.println("\t\treturn (" + subloop.getJavaType() + ") children.get(idx);");
                out.println("\t}");
                out.println();
            }

            if (getParentLoop() != null) {
                X12Loop subloop = (X12Loop) getParentLoop();

                out.println("\tprivate " + subloop.getJavaType() + " parent;");
                out.println("\tpublic " + subloop.getJavaType() + " getParent() { return parent; }");
                out.println(
                        "\tpublic void setParent(" + subloop.getJavaType()
                        + " dad) { parent = dad; }");
                out.println();
            }

            emitSegmentVariables(xaType, out);
            emitLoopVariables(xaType, out);
            emitLoopParsing(out);
            emitLoopEmitting(out);
            emitLoopCloning(out);

            out.println("}");

        }
        finally {
            out.close();
            fw.close();
        }

        if (generateSubclassFiles) {
            fw = new FileWriter(getJavaType() + ".java");
            out = new PrintWriter(fw);
            try {
                out.println("package com.webify.shared.edi.model.hipaa" + xaType + ";");
                out.println();
                out.println("import com.webify.shared.edi.model.*;");
                out.println(
                        "import com.webify.shared.edi.model.hipaa" + xaType + ".beans.Base"
                        + getJavaType() + ";");
                out.println("import org.apache.commons.logging.Log;");
                out.println("import org.apache.commons.logging.LogFactory;");
                out.println();
                out.println("/*");
                out.println(
                        " * Base" + getJavaType()
                        + " subclass, put any business logic in this class");
                out.println(" */");
                out.println("public class " + getJavaType() + " extends Base" + getJavaType() + " {");
                out.println();
                out.println(
                        "\tprivate static final Log log = LogFactory.getLog(" + getJavaType()
                        + ".class);");
                out.println();
                out.println("\t/*");
                out.println("\t * Uncomment this to hook into the input validation.  This method is");
                out.println("\t * called when an EDI file is parsed into a document.");
                out.println("\tprotected void validate(EDIInputStream eis) {");
                out.println("\t\tsuper.validate(eis);");
                out.println("\t}");
                out.println("\t*/");
                out.println("}");
            }
            finally {
                out.close();
                fw.close();
            }
        }

    }

    private void emitLoopCloning(PrintWriter out) {
        out.println("\tpublic EDIElement createCopy() {");
        out.println("\t\t" + getJavaType() + " thisCopy = new " + getJavaType() + "();");
        out.println("\t\tthisCopy.setStartLineNumber(this.startLineNumber);");
        out.println("\t\tthisCopy.setEndLineNumber(this.endLineNumber);");
        out.println();

        /*
         if (getChildLoop() != null) {
         X12Loop subloop = (X12Loop) getChildLoop();
         out.println("\t\tList newkids = new ArrayList(getChildList().size());");
         out.println("\t\tfor (Iterator it = getChildList().iterator(); it.hasNext();) {");
         out.println("\t\t\tnewkids.add(((" + subloop.getJavaType() + ")it.next()).createCopy());");
         out.println("\t\t}");
         out.println("\t\tthisCopy.setChildList(newkids);");
         out.println();
         }
         */

        boolean emittedHierarchy = false;

        for (Iterator it = getElements().iterator(); it.hasNext();) {
            X12Element elm = (X12Element) it.next();
            X12Loop loop = null;
            X12SegmentReference seg = null;

            if (elm instanceof X12Loop) {
                loop = (X12Loop) elm;
            }
            else if (elm instanceof X12SegmentReference) {
                seg = (X12SegmentReference) elm;
            }
            String var = (elm instanceof X12Loop ? "loop" : "") + elm.getCamelName();

            if (hasHierarchy && hierarchy.contains(loop)) {
                if (!emittedHierarchy) {
                    emittedHierarchy = true;
                    int hidx = 0;

                    emitRecursiveCopy(hidx, out);
                    out.println();
                }
                continue;
            }

            out.println("\t\tif (" + var + " != null) {");
            if (loop != null && loop.getMaxUsage() > 1) {
                out.println("\t\t\tthisCopy.setLoop" + loop.getName() + "(new ArrayList());");
                out.println("\t\t\tint idx = 0, size = " + var + ".size();");
                out.println("\t\t\twhile (idx < size) {");

                out.println(
                        "\t\t\t\tthisCopy.getLoop" + loop.getName() + "().add(getLoop"
                        + loop.getName() + "(idx++).createCopy());");
                out.println("\t\t\t}");
            }
            else if (seg != null && seg.getMaxUsage() > 1) {
                out.println("\t\t\tthisCopy.set" + var + "(new ArrayList());");
                out.println("\t\t\tint idx = 0, size = " + var + ".size();");
                out.println("\t\t\twhile (idx < size) {");
                out.println(
                        "\t\t\t\tthisCopy.get" + var + "().add(get" + seg.getCamelName()
                        + "(idx++).createCopy());");
                out.println("\t\t\t}");
            }
            else if (seg != null) {
                out.println(
                        "\t\t\tthisCopy.set" + var + "((" + seg.getJavaType() + ")" + var
                        + ".createCopy());");
            }
            else if (loop != null) {
                out.println(
                        "\t\t\tthisCopy.setLoop" + loop.getName() + "((" + loop.getJavaType() + ")"
                        + var + ".createCopy());");
            }
            out.println("\t\t}");
            out.println();
        }
        out.println("\t\treturn thisCopy;");
        out.println("\t}");
        out.println();
    }

    private void emitRecursiveCopy(int hidx, PrintWriter out) {
        if (hidx >= hierarchy.size()) {
            return;
        }
        char idxVar = 'i';

        idxVar += hidx;

        X12Loop loop = (X12Loop) hierarchy.get(hidx);
        String var = "current" + loop.getName();
        String object = (hidx == 0 ? "this" : "current" + loop.getParentLoop().getName());

        out.println(
                tabs(hidx) + "\t\tfor (int " + idxVar + " = 0; " + idxVar + " < " + object
                + ".getChildList().size(); " + idxVar + "++) {");
        out.println(
                tabs(hidx) + "\t\t\t" + loop.getJavaType() + " " + var + " = " + object
                + ".getChild(" + idxVar + ");");
        out.println(
                tabs(hidx) + "\t\t\t" + loop.getJavaType() + " " + var + "Copy = ("
                + loop.getJavaType() + ") " + var + ".createCopy();");
        out.println(tabs(hidx) + "\t\t\t" + object + "Copy.addChild(" + var + "Copy);");
        emitRecursiveCopy(hidx + 1, out);
        out.println(tabs(hidx) + "\t\t}");
    }

    private void emitLoopEmitting(PrintWriter out) throws IOException {
        boolean emittedHierarchy = false;

        out.println("\tpublic void emit(EDIOutputStream eos) throws IOException {");
        for (Iterator it = getElements().iterator(); it.hasNext();) {
            X12Element elm = (X12Element) it.next();
            X12Loop loop = null;
            X12SegmentReference seg = null;

            if (elm instanceof X12Loop) {
                loop = (X12Loop) elm;
            }
            else if (elm instanceof X12SegmentReference) {
                seg = (X12SegmentReference) elm;
            }
            String var = (elm instanceof X12Loop ? "loop" : "") + elm.getCamelName();

            if (hasHierarchy && hierarchy.contains(loop)) {
                if (!emittedHierarchy) {
                    emittedHierarchy = true;
                    int hidx = 0;

                    out.println("\t\tint hlidx = 1;");
                    emitRecursiveWrite(hidx, out);
                    out.println();
                }
                continue;
            }

            out.println("\t\tif (" + var + " != null) {");
            if (loop != null && loop.getMaxUsage() > 1) {
                out.println("\t\t\tint idx = 0, size = " + var + ".size();");
                out.println("\t\t\twhile (idx < size) {");
                out.println("\t\t\t\tget" + loop.getJavaType() + "(idx++).emit(eos);");
                out.println("\t\t\t}");
            }
            else if (seg != null && seg.getMaxUsage() > 1) {
                out.println("\t\t\tint idx = 0, size = " + var + ".size();");
                out.println("\t\t\twhile (idx < size) {");
                out.println("\t\t\t\tget" + seg.getCamelName() + "(idx++).emit(eos);");
                out.println("\t\t\t}");
            }
            else {
                out.println("\t\t\t" + var + ".emit(eos);");
            }
            if (elm.getUsageNote() == X12Element.USAGE_MUST_USE) {
                out.println("\t\t} else {");
                out.println("\t\t\teos.addError(\"Missing mandatory segment '" 
                        + var.toUpperCase() + "'\");");
            }
            out.println("\t\t}");
            out.println();
        }

        out.println("\t}");
        out.println();
    }

    // for (int i = 0; i < getChildList().size(); i++) {
    // Loop2000A current2000A = getChild(i);
    // current2000A.emit();
    // for (int i = 0; i < getChildList().size(); i++) {
    // Loop2000B current2000B = getChild(i);
    // current2000B.emit();
    private void emitRecursiveWrite(int hidx, PrintWriter out) throws IOException {
        if (hidx >= hierarchy.size()) {
            return;
        }
        char idxVar = 'i';

        idxVar += hidx;

        X12Loop loop = (X12Loop) hierarchy.get(hidx);
        String var = "current" + loop.getName();
        String object = (hidx == 0 ? "this" : "current" + loop.getParentLoop().getName());

        out.println(
                tabs(hidx) + "\t\tfor (int " + idxVar + " = 0; " + idxVar + " < " + object
                + ".getChildList().size(); " + idxVar + "++) {");
        out.println(
                tabs(hidx) + "\t\t\t" + loop.getJavaType() + " " + var + " = " + object
                + ".getChild(" + idxVar + ");");
        out.println(tabs(hidx) + "\t\t\tint " + var + "HL = hlidx++;");
        out.println(
                tabs(hidx) + "\t\t\t" + var + ".getHl().setHl01(Integer.toString(" + var + "HL));");
        if (hidx != 0) {
            out.println(
                    tabs(hidx) + "\t\t\t" + var + ".getHl().setHl02(Integer.toString(current"
                    + loop.getParentLoop().getName() + "HL));");
        }
        if (loop.getChildLoop() != null) {
            out.println(
                    tabs(hidx) + "\t\t\t" + var + ".getHl().setHl04((" + var
                    + ".getChildList().size() > 0 ? \"1\" : \"0\"));");
        }
        else {
            X12SegmentReference hl = (X12SegmentReference) loop.getSegmentReferences().get(0);

            // Dang 277's HL mask 3 does not have an HL04 field
            if (hl.getMask() != 3) {
                out.println(tabs(hidx) + "\t\t\t" + var + ".getHl().setHl04(\"0\");");
            }
        }
        out.println(tabs(hidx) + "\t\t\t" + var + ".emit(eos);");
        emitRecursiveWrite(hidx + 1, out);
        out.println(tabs(hidx) + "\t\t}");
    }

    private void emitLoopVariables(String xaType, PrintWriter out) throws IOException {
        out.println("\t// Loops");
        for (Iterator it = getLoops().iterator(); it.hasNext();) {
            X12Loop loop = (X12Loop) it.next();

            loop.emit(xaType);

            if (loop.getParentLoop() != null) {
                continue;
            }

            String var = "loop" + loop.getName();

            if (loop.getMaxUsage() == 1) {
                out.println("\tprivate " + loop.getJavaType() + " " + var + ";");
                out.println(
                        "\tpublic " + loop.getJavaType() + " getLoop" + loop.getName()
                        + "() { return " + var + "; }");
                out.println(
                        "\tpublic void setLoop" + loop.getName() + "(" + loop.getJavaType()
                        + " loop) { " + var + " = loop; }");
                out.println();
            }
            else {
                out.println("\tprivate List " + var + ";");
                out.println(
                        "\tpublic " + loop.getJavaType() + " getLoop" + loop.getName()
                        + "(int idx) { ");
                out.println("\t\tif (" + var + " == null || idx >= " + var + ".size()) {");
                out.println("\t\t\tthrow new ArrayIndexOutOfBoundsException(\"" + var + "\");");
                out.println("\t\t}");
                out.println("\t\treturn (" + loop.getJavaType() + ") " + var + ".get(idx);");
                out.println("\t}");
                out.println("\tpublic List getLoop" + loop.getName() + "() {");
                out.println("\t\treturn " + var + ";");
                out.println("\t}");
                out.println(
                        "\tpublic void setLoop" + loop.getName() + "(List loop) { " + var
                        + " = loop; }");
                out.println();
            }

        }
        out.println();
    }

    private void emitSegmentVariables(String xaType, PrintWriter out) throws IOException {
        out.println("\t// Segments");
        int i = 0;

        for (Iterator it = getSegmentReferences().iterator(); it.hasNext(); i++) {
            X12SegmentReference seg = (X12SegmentReference) it.next();
            X12Segment s = seg.getSegment();

            s.emit(xaType,
                    (X12Mask) (seg.getMask() > 0 ? s.getMasks().get(seg.getMask() - 1) : null),
                    seg.getMask());

            
            String sname = seg.getCamelName();
            
            if (seg.getMaxUsage() == 1) {
                out.println("\tprivate " + seg.getJavaType() + " " + sname + ";");
                out.println(
                        "\tpublic " + seg.getJavaType() + " get" + sname + "() { return "
                        + sname + "; }");
                out.println(
                        "\tpublic void set" + sname + "(" + seg.getJavaType() + " seg) { "
                        + sname + " = seg; }");
                out.println();
            }
            else {
                String var = sname;

                out.println("\tprivate List " + var + ";");
                out.println("\tpublic " + seg.getJavaType() + " get" + var + "(int idx) { ");
                out.println("\t\tif (" + var + " == null || idx >= " + var + ".size()) {");
                out.println("\t\t\tthrow new ArrayIndexOutOfBoundsException(\"" + var + "\");");
                out.println("\t\t}");
                out.println("\t\treturn (" + seg.getJavaType() + ") " + var + ".get(idx);");
                out.println("\t}");
                out.println("\tpublic List get" + sname + "() {");
                out.println("\t\treturn " + var + ";");
                out.println("\t}");
                out.println(
                        "\tpublic void set" + sname + "(List segs) { " + var + " = segs; }");
                out.println();
            }

            seg.emit(xaType);
        }
        out.println();
    }

    private List hierarchy = null;

    private void precalculateHierarchy() {
        // Determine if this Loop has an implied hierarchy denoted by
        // subloops starting with an HL segment
        // An 837P transaction has an implied hierarchy:
        // 837P
        // 1000A
        // 1000B
        // 2000A
        // 2000B
        // 2000C
        // We need to track this to make editing and emitting work correctly.

        hierarchy = new ArrayList();
        for (Iterator lit = getLoops().iterator(); lit.hasNext();) {
            X12Loop loop = (X12Loop) lit.next();
            X12SegmentReference seg = (X12SegmentReference) loop.getSegmentReferences().get(0);

            if ("HL".equals(seg.getName())) {
                hierarchy.add(loop);
                hasHierarchy = true;
            }
        }

        for (int i = 0; i < hierarchy.size(); i++) {
            X12Loop cur = (X12Loop) hierarchy.get(i);

            if (i > 0) {
                cur.setParentLoop((X12Loop) hierarchy.get(i - 1));
            }
            if (i + 1 < hierarchy.size()) {
                cur.setChildLoop((X12Loop) hierarchy.get(i + 1));
            }
            if (i == 0) {
                setChildLoop(cur);
                cur.setParentLoop(this);
            }
        }
    }

    private void emitLoopParsing(PrintWriter out) {
        boolean loopsStarted = false;
        boolean emittedHierarchy = false;

        out.println("\tpublic void parse(EDIInputStream eis) throws IOException {");
        out.println("\t\tif (log.isDebugEnabled()) log.debug(\"Starting loop " + getName() + "\");");
        out.println("\t\tstartLineNumber = eis.getCurrentSegmentNumber() + 1;");
        out.println();

        for (int i = 0; i < getElements().size(); i++) {
            X12Element elm = (X12Element) getElements().get(i);

            if (elm instanceof X12SegmentReference) {
                emitParseSegment(out, i, elm);
            }
            else {
                X12Loop l = (X12Loop) elm;

                if (hasHierarchy && hierarchy.contains(l)) {
                    if (!emittedHierarchy) {
                        emittedHierarchy = true;
                        int hidx = 0;

                        emitRecursiveRead(hidx, out);
                        out.println();
                    }
                    continue;
                }

                loopsStarted = emitParseSubloop(out, loopsStarted, l);
            }
        }

        out.println("\t\tendLineNumber = eis.getCurrentSegmentNumber();");
        out.println("\t\tvalidate(eis);");
        out.println("\t}");
        out.println();
    }

    private boolean emitParseSubloop(PrintWriter out, boolean loopsStarted, X12Loop l) {
        boolean started = loopsStarted;
        if (!started) {
            out.println("\t\twhile (true) {");
            int count = 0;

            for (Iterator lit = getLoops().iterator(); lit.hasNext(); count++) {
                X12Loop loop = (X12Loop) lit.next();

                if (hasHierarchy && hierarchy.contains(loop)) {
                    continue;
                }
                X12LoopTrigger trg = loop.getTrigger();
                X12SegmentReference seg1 = (X12SegmentReference) loop.getElements().get(0);

                if (loop.getMaxUsage() > 1) {
                    if (trg == null) {
                        out.println(
                                "\t\t\t" + (count == 0 ? "" : "else ")
                                + "if (eis.peekSegment(\"" + seg1.getName() + "\")) {");
                    }
                    else {
                        out.println(
                                "\t\t\t" + (count == 0 ? "" : "else ")
                                + "if (eis.peekSegment(\"" + seg1.getName() + "\", "
                                + trg.getFieldIdx() + ", " + loop.getJavaType()
                                + ".TRIGGER_VALUES)) {");
                    }
                    out.println(
                            "\t\t\t\tif (loop" + loop.getName() + " == null) loop"
                            + loop.getName() + " = new ArrayList();");
                    out.println(
                            "\t\t\t\t" + loop.getJavaType() + " tmp = new "
                            + loop.getJavaType() + "();");
                    out.println("\t\t\t\ttmp.parse(eis);");
                    out.println("\t\t\t\tloop" + loop.getName() + ".add(tmp);");
                    out.println("\t\t\t}");
                }
                else {
                    if (trg == null) {
                        out.println(
                                "\t\t\t" + (count == 0 ? "" : "else ")
                                + "if (eis.peekSegment(\"" + seg1.getName() + "\")) {");
                    }
                    else {
                        out.println(
                                "\t\t\t" + (count == 0 ? "" : "else ")
                                + "if (eis.peekSegment(\"" + seg1.getName() + "\", "
                                + trg.getFieldIdx() + ", " + loop.getJavaType()
                                + ".TRIGGER_VALUES)) {");
                    }
                    out.println("\t\t\t\tif (loop" + loop.getName() + " != null) {");
                    out.println(
                            "\t\t\t\t\teis.addError(\"Only one instance of Loop "
                                    + loop.getName() + " is allowed.\");");
                    out.println("\t\t\t\t} else {");
                    out.println(
                            "\t\t\t\t\tloop" + loop.getName() + " = new "
                            + loop.getJavaType() + "();");
                    out.println("\t\t\t\t\tloop" + loop.getName() + ".parse(eis);");
                    out.println("\t\t\t\t}");
                    out.println("\t\t\t}");
                }
            }
            out.println("\t\t\telse {");
            out.println("\t\t\t\tbreak;");
            out.println("\t\t\t}");
            out.println("\t\t}");
            out.println();
            started = true;
        }

        if (l.getMaxUsage() > 1) {
            if (l.getUsageNote() == X12Element.USAGE_MUST_USE) {
                out.println("\t\tif (loop" + l.getName() + " == null) {");
                out.println(
                        "\t\t\teis.addError(\"Loop " + l.getName() + " must be used.\");");
                out.println("\t\t}");
            }
            if (l.getMaxUsage() != Short.MAX_VALUE) {
                out.println(
                        "\t\tif (loop" + l.getName() + " != null && loop" + l.getName()
                        + ".size() > " + l.getMaxUsage() + ") {");
                out.println(
                        "\t\t\teis.addError(\"Loop " + l.getName()
                        + " has too many instances.  It can repeat only " + l.getMaxUsage()
                        + " times\");");
                out.println("\t\t}");
            }
        }
        else {
            if (l.getUsageNote() == X12Element.USAGE_MUST_USE) {
                out.println("\t\tif (loop" + l.getName() + " == null) {");
                out.println(
                        "\t\t\teis.addError(\"An instance of Loop " + l.getName()
                        + " is required.\");");
                out.println("\t\t}");
            }
        }
        return started;
    }

    private void emitParseSegment(PrintWriter out, int i, X12Element elm) {
        X12SegmentReference seg = (X12SegmentReference) elm;
        X12SegmentTrigger trg = X12Handler.getInstance().getSegmentTrigger(
                getName() + ":" + seg.getName());

        if (seg.getMaxUsage() > 1) {
            emitParseMultiSegment(out, i, elm, seg, trg);
        }
        else {
            if (seg.getUsageNote() == X12Element.USAGE_MUST_USE) {
                if (trg == null) {
                    out.println("\t\tif (!eis.peekSegment(\"" + seg.getBaseName() + "\")) {");
                }
                else {
                    out.println(
                            "\t\tif (!eis.peekSegment(\"" + seg.getBaseName() + "\", "
                            + trg.getFieldIdx() + ", " + trg.getValuesString() + ")) {");
                }
                out.println(
                        "\t\t\teis.addError(\"A single instance of Segment "
                                + seg.getBaseName() + " is required.\");");
                out.println("\t\t} else {");
                out.println("\t\t\t" + elm.getCamelName() + " = new " + seg.getJavaType() + "();");
                out.println(
                        "\t\t\t" + elm.getCamelName() + ".setOrdinal(" + seg.getOrdinal() + ");");
                out.println("\t\t\t" + elm.getCamelName() + ".parse(eis);");
                out.println("\t\t}");
            }
            else { // limited to one
                if (trg == null) {
                    out.println("\t\tif (eis.peekSegment(\"" + seg.getBaseName() + "\")) {");
                }
                else {
                    out.println(
                            "\t\tif (eis.peekSegment(\"" + seg.getBaseName() + "\", "
                            + trg.getFieldIdx() + ", " + trg.getValuesString() + ")) {");
                }
                out.println("\t\t\t" + elm.getCamelName() + " = new " + seg.getJavaType() + "();");
                out.println(
                        "\t\t\t" + elm.getCamelName() + ".setOrdinal(" + seg.getOrdinal() + ");");
                out.println("\t\t\t" + elm.getCamelName() + ".parse(eis);");
                out.println("\t\t}");
            }

            // Add a check to make sure we eat any lingering segments with the same name due to errors in the
            // file.
            // There was a case where we got an 837P with a segment "REF**19292~".  The data model parses REF
            // segments according to the value in field 01 so this segment did not parse at all.  This check
            // is to ensure we just skip that segment and continue parsing
            if (i + 1 < getElements().size() && trg != null) {
                X12Element nextelm = (X12Element) getElements().get(i + 1);

                if (nextelm instanceof X12SegmentReference) {
                    X12SegmentReference nextseg = (X12SegmentReference) nextelm;

                    if (!nextseg.getBaseName().equals(seg.getBaseName())) {
                        out.println(
                                "\t\tif (eis.peekSegment(\"" + seg.getBaseName() + "\")) {");
                        out.println(
                                "\t\t\teis.addError(\"Segment " + seg.getBaseName()
                                + " could not be parsed.\");");
                        out.println("\t\t\teis.eatSegments(\"" + seg.getBaseName() + "\");");
                        out.println("\t\t}");
                    }
                }
            }

        }
        out.println();
    }

    private void emitParseMultiSegment(PrintWriter out, int i, X12Element elm, X12SegmentReference seg,
                    X12SegmentTrigger trg) {
        if (trg == null) {
            out.println("\t\twhile (eis.peekSegment(\"" + seg.getBaseName() + "\")) {");
        }
        else {
            out.println(
                    "\t\twhile (eis.peekSegment(\"" + seg.getBaseName() + "\", "
                    + trg.getFieldIdx() + ", " + trg.getValuesString() + ")) {");
        }
        out.println(
                "\t\t\tif (" + elm.getCamelName() + " == null) " + elm.getCamelName()
                + " = new ArrayList();");
        out.println(
                "\t\t\t" + seg.getJavaType() + " tmp = new " + seg.getJavaType() + "();");
        out.println("\t\t\ttmp.setOrdinal(" + seg.getOrdinal() + ");");
        out.println("\t\t\ttmp.parse(eis);");
        out.println("\t\t\t" + elm.getCamelName() + ".add(tmp);");
        if (seg.getMaxUsage() != Short.MAX_VALUE) {
            out.println(
                    "\t\t\tif (" + elm.getCamelName() + ".size() > " + seg.getMaxUsage()
                    + ") {");
            out.println(
                    "\t\t\t\teis.addError(\"Segment " + seg.getBaseName()
                    + " has too many instances.  It can only repeat "
                    + seg.getMaxUsage() + " times\");");
            out.println("\t\t\t\teis.eatSegments(\"" + seg.getBaseName() + "\");");
            out.println("\t\t\t\tbreak;");
            out.println("\t\t\t}");
        }
        out.println("\t\t}");
        if (seg.getUsageNote() == X12Element.USAGE_MUST_USE) {
            out.println("\t\tif (" + elm.getCamelName() + ".size() == 0) {");
            out.println(
                    "\t\t\teis.addError(\"Segment '" + seg.getBaseName()
                    + "' is marked MUST_USE.  It is required but no instances were found.\");");
            out.println("\t\t}");
        }

        // Add a check to make sure we eat any lingering segments with the same name due to errors
        // in the file.  There was a case where we got an 837P with a segment "REF**19292~".  The
        // data model parses REF segments according to the value in field 01 so this segment did
        // not parse at all.  This check is to ensure we just skip that segment and continue parsing.
        if (i + 1 < getElements().size() && trg != null) {
            X12Element nextelm = (X12Element) getElements().get(i + 1);

            if (nextelm instanceof X12SegmentReference) {
                X12SegmentReference nextseg = (X12SegmentReference) nextelm;

                if (!nextseg.getBaseName().equals(seg.getBaseName())) {
                    out.println(
                            "\t\tif (eis.peekSegment(\"" + seg.getBaseName() + "\")) {");
                    out.println(
                            "\t\t\teis.addError(\"Segment " + seg.getBaseName()
                            + " could not be parsed.\");");
                    out.println("\t\t\teis.eatSegments(\"" + seg.getBaseName() + "\");");
                    out.println("\t\t}");
                }
            }
        }
    }

    private void emitRecursiveRead(int hidx, PrintWriter out) {
        if (hidx >= hierarchy.size()) {
            return;
        }

        X12Loop loop = (X12Loop) hierarchy.get(hidx);
        X12LoopTrigger trg = loop.getTrigger();
        X12SegmentReference seg1 = (X12SegmentReference) loop.getElements().get(0);

        if (loop.getMaxUsage() > 1) {
            if (trg == null) {
                out.println(tabs(hidx) + "\t\twhile (eis.peekSegment(\"" + seg1.getName() + "\")) {");
            }
            else {
                out.println(
                        tabs(hidx) + "\t\twhile (eis.peekSegment(\"" + seg1.getName() + "\", "
                        + trg.getFieldIdx() + ", " + loop.getJavaType() + ".TRIGGER_VALUES)) {");
            }
            out.println(
                    tabs(hidx) + "\t\t\t" + loop.getJavaType() + " current" + loop.getName()
                    + " = new " + loop.getJavaType() + "();");
            out.println(tabs(hidx) + "\t\t\tcurrent" + loop.getName() + ".parse(eis);");
            out.println(
                    tabs(hidx) + "\t\t\tcurrent" + loop.getName() + ".setParent("
                    + (hidx == 0
                            ? "(" + loop.getParentLoop().getJavaType() + ")this"
                            : "current" + loop.getParentLoop().getName())
                            + ");");
            emitRecursiveRead(hidx + 1, out);
            out.println(
                    tabs(hidx) + "\t\t\tcurrent" + loop.getName()
                    + ".setEndLineNumber(eis.getCurrentSegmentNumber());");
            out.println(
                    tabs(hidx) + "\t\t\t"
                    + (hidx == 0 ? "this" : "current" + loop.getParentLoop().getName())
                    + ".addChild(current" + loop.getName() + ");");
            out.println(tabs(hidx) + "\t\t}");
        }
        else {
            if (trg == null) {
                out.println(tabs(hidx) + "\t\tif (eis.peekSegment(\"" + seg1.getName() + "\")) {");
            }
            else {
                out.println(
                        tabs(hidx) + "\t\tif (eis.peekSegment(\"" + seg1.getName() + "\", "
                        + trg.getFieldIdx() + ", " + loop.getJavaType() + ".TRIGGER_VALUES)) {");
            }
            out.println(tabs(hidx) + "\t\t\tif (loop" + loop.getName() + " != null) {");
            out.println(
                    tabs(hidx) + "\t\t\t\teis.addError(\"Only one instance of Loop "
                    + loop.getName() + " is allowed.\");");
            out.println(tabs(hidx) + "\t\t\t} else {");
            out.println(
                    tabs(hidx) + "\t\t\t" + loop.getJavaType() + " current" + loop.getName()
                    + " = new " + loop.getJavaType() + "();");
            out.println(tabs(hidx) + "\t\t\tcurrent" + loop.getName() + ".parse(eis);");
            out.println(
                    tabs(hidx) + "\t\t\tcurrent" + loop.getName() + ".setParent("
                    + (hidx == 0 ? "this" : "current" + loop.getParentLoop().getName()) + ");");
            emitRecursiveRead(hidx + 1, out);
            out.println(
                    tabs(hidx) + "\t\t\t"
                    + (hidx == 0 ? "this" : "current" + loop.getParentLoop().getName())
                    + ".addChild(current" + loop.getName() + ");");
            out.println(tabs(hidx) + "\t\t\t}");
            out.println(tabs(hidx) + "\t\t}");
        }
    }

    private static final String TABS = "\t\t\t\t\t\t\t\t\t";

    private String tabs(int hidx) {
        return TABS.substring(0, hidx);
    }

    protected void emitHeader(PrintWriter out, String xaType) {
        out.println("public class Base" + getJavaType() + " extends EDILoop {");
    }

    public void setTrigger(X12LoopTrigger trigger) {
        this.trigger = trigger;
    }

    public X12LoopTrigger getTrigger() {
        return trigger;
    }

    public X12Loop getChildLoop() {
        return childLoop;
    }

    public X12Loop getParentLoop() {
        return parentLoop;
    }

    public void setChildLoop(X12Loop loop) {
        childLoop = loop;
    }

    public void setParentLoop(X12Loop loop) {
        parentLoop = loop;
    }

}
